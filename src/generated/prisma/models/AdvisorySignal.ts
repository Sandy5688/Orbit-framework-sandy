
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `AdvisorySignal` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model AdvisorySignal
 * 
 */
export type AdvisorySignalModel = runtime.Types.Result.DefaultSelection<Prisma.$AdvisorySignalPayload>

export type AggregateAdvisorySignal = {
  _count: AdvisorySignalCountAggregateOutputType | null
  _avg: AdvisorySignalAvgAggregateOutputType | null
  _sum: AdvisorySignalSumAggregateOutputType | null
  _min: AdvisorySignalMinAggregateOutputType | null
  _max: AdvisorySignalMaxAggregateOutputType | null
}

export type AdvisorySignalAvgAggregateOutputType = {
  confidence: number | null
}

export type AdvisorySignalSumAggregateOutputType = {
  confidence: number | null
}

export type AdvisorySignalMinAggregateOutputType = {
  id: string | null
  profileId: string | null
  cycleRunId: string | null
  signal: string | null
  confidence: number | null
  recommendation: string | null
  createdAt: Date | null
}

export type AdvisorySignalMaxAggregateOutputType = {
  id: string | null
  profileId: string | null
  cycleRunId: string | null
  signal: string | null
  confidence: number | null
  recommendation: string | null
  createdAt: Date | null
}

export type AdvisorySignalCountAggregateOutputType = {
  id: number
  profileId: number
  cycleRunId: number
  signal: number
  confidence: number
  recommendation: number
  createdAt: number
  _all: number
}


export type AdvisorySignalAvgAggregateInputType = {
  confidence?: true
}

export type AdvisorySignalSumAggregateInputType = {
  confidence?: true
}

export type AdvisorySignalMinAggregateInputType = {
  id?: true
  profileId?: true
  cycleRunId?: true
  signal?: true
  confidence?: true
  recommendation?: true
  createdAt?: true
}

export type AdvisorySignalMaxAggregateInputType = {
  id?: true
  profileId?: true
  cycleRunId?: true
  signal?: true
  confidence?: true
  recommendation?: true
  createdAt?: true
}

export type AdvisorySignalCountAggregateInputType = {
  id?: true
  profileId?: true
  cycleRunId?: true
  signal?: true
  confidence?: true
  recommendation?: true
  createdAt?: true
  _all?: true
}

export type AdvisorySignalAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which AdvisorySignal to aggregate.
   */
  where?: Prisma.AdvisorySignalWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of AdvisorySignals to fetch.
   */
  orderBy?: Prisma.AdvisorySignalOrderByWithRelationInput | Prisma.AdvisorySignalOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.AdvisorySignalWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` AdvisorySignals from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` AdvisorySignals.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned AdvisorySignals
  **/
  _count?: true | AdvisorySignalCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: AdvisorySignalAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: AdvisorySignalSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: AdvisorySignalMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: AdvisorySignalMaxAggregateInputType
}

export type GetAdvisorySignalAggregateType<T extends AdvisorySignalAggregateArgs> = {
      [P in keyof T & keyof AggregateAdvisorySignal]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateAdvisorySignal[P]>
    : Prisma.GetScalarType<T[P], AggregateAdvisorySignal[P]>
}




export type AdvisorySignalGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.AdvisorySignalWhereInput
  orderBy?: Prisma.AdvisorySignalOrderByWithAggregationInput | Prisma.AdvisorySignalOrderByWithAggregationInput[]
  by: Prisma.AdvisorySignalScalarFieldEnum[] | Prisma.AdvisorySignalScalarFieldEnum
  having?: Prisma.AdvisorySignalScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: AdvisorySignalCountAggregateInputType | true
  _avg?: AdvisorySignalAvgAggregateInputType
  _sum?: AdvisorySignalSumAggregateInputType
  _min?: AdvisorySignalMinAggregateInputType
  _max?: AdvisorySignalMaxAggregateInputType
}

export type AdvisorySignalGroupByOutputType = {
  id: string
  profileId: string
  cycleRunId: string | null
  signal: string
  confidence: number
  recommendation: string
  createdAt: Date
  _count: AdvisorySignalCountAggregateOutputType | null
  _avg: AdvisorySignalAvgAggregateOutputType | null
  _sum: AdvisorySignalSumAggregateOutputType | null
  _min: AdvisorySignalMinAggregateOutputType | null
  _max: AdvisorySignalMaxAggregateOutputType | null
}

type GetAdvisorySignalGroupByPayload<T extends AdvisorySignalGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<AdvisorySignalGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof AdvisorySignalGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], AdvisorySignalGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], AdvisorySignalGroupByOutputType[P]>
      }
    >
  >



export type AdvisorySignalWhereInput = {
  AND?: Prisma.AdvisorySignalWhereInput | Prisma.AdvisorySignalWhereInput[]
  OR?: Prisma.AdvisorySignalWhereInput[]
  NOT?: Prisma.AdvisorySignalWhereInput | Prisma.AdvisorySignalWhereInput[]
  id?: Prisma.StringFilter<"AdvisorySignal"> | string
  profileId?: Prisma.StringFilter<"AdvisorySignal"> | string
  cycleRunId?: Prisma.StringNullableFilter<"AdvisorySignal"> | string | null
  signal?: Prisma.StringFilter<"AdvisorySignal"> | string
  confidence?: Prisma.FloatFilter<"AdvisorySignal"> | number
  recommendation?: Prisma.StringFilter<"AdvisorySignal"> | string
  createdAt?: Prisma.DateTimeFilter<"AdvisorySignal"> | Date | string
}

export type AdvisorySignalOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  profileId?: Prisma.SortOrder
  cycleRunId?: Prisma.SortOrderInput | Prisma.SortOrder
  signal?: Prisma.SortOrder
  confidence?: Prisma.SortOrder
  recommendation?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type AdvisorySignalWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.AdvisorySignalWhereInput | Prisma.AdvisorySignalWhereInput[]
  OR?: Prisma.AdvisorySignalWhereInput[]
  NOT?: Prisma.AdvisorySignalWhereInput | Prisma.AdvisorySignalWhereInput[]
  profileId?: Prisma.StringFilter<"AdvisorySignal"> | string
  cycleRunId?: Prisma.StringNullableFilter<"AdvisorySignal"> | string | null
  signal?: Prisma.StringFilter<"AdvisorySignal"> | string
  confidence?: Prisma.FloatFilter<"AdvisorySignal"> | number
  recommendation?: Prisma.StringFilter<"AdvisorySignal"> | string
  createdAt?: Prisma.DateTimeFilter<"AdvisorySignal"> | Date | string
}, "id">

export type AdvisorySignalOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  profileId?: Prisma.SortOrder
  cycleRunId?: Prisma.SortOrderInput | Prisma.SortOrder
  signal?: Prisma.SortOrder
  confidence?: Prisma.SortOrder
  recommendation?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.AdvisorySignalCountOrderByAggregateInput
  _avg?: Prisma.AdvisorySignalAvgOrderByAggregateInput
  _max?: Prisma.AdvisorySignalMaxOrderByAggregateInput
  _min?: Prisma.AdvisorySignalMinOrderByAggregateInput
  _sum?: Prisma.AdvisorySignalSumOrderByAggregateInput
}

export type AdvisorySignalScalarWhereWithAggregatesInput = {
  AND?: Prisma.AdvisorySignalScalarWhereWithAggregatesInput | Prisma.AdvisorySignalScalarWhereWithAggregatesInput[]
  OR?: Prisma.AdvisorySignalScalarWhereWithAggregatesInput[]
  NOT?: Prisma.AdvisorySignalScalarWhereWithAggregatesInput | Prisma.AdvisorySignalScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"AdvisorySignal"> | string
  profileId?: Prisma.StringWithAggregatesFilter<"AdvisorySignal"> | string
  cycleRunId?: Prisma.StringNullableWithAggregatesFilter<"AdvisorySignal"> | string | null
  signal?: Prisma.StringWithAggregatesFilter<"AdvisorySignal"> | string
  confidence?: Prisma.FloatWithAggregatesFilter<"AdvisorySignal"> | number
  recommendation?: Prisma.StringWithAggregatesFilter<"AdvisorySignal"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"AdvisorySignal"> | Date | string
}

export type AdvisorySignalCreateInput = {
  id?: string
  profileId: string
  cycleRunId?: string | null
  signal: string
  confidence: number
  recommendation: string
  createdAt?: Date | string
}

export type AdvisorySignalUncheckedCreateInput = {
  id?: string
  profileId: string
  cycleRunId?: string | null
  signal: string
  confidence: number
  recommendation: string
  createdAt?: Date | string
}

export type AdvisorySignalUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  profileId?: Prisma.StringFieldUpdateOperationsInput | string
  cycleRunId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  signal?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  recommendation?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type AdvisorySignalUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  profileId?: Prisma.StringFieldUpdateOperationsInput | string
  cycleRunId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  signal?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  recommendation?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type AdvisorySignalCreateManyInput = {
  id?: string
  profileId: string
  cycleRunId?: string | null
  signal: string
  confidence: number
  recommendation: string
  createdAt?: Date | string
}

export type AdvisorySignalUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  profileId?: Prisma.StringFieldUpdateOperationsInput | string
  cycleRunId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  signal?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  recommendation?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type AdvisorySignalUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  profileId?: Prisma.StringFieldUpdateOperationsInput | string
  cycleRunId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  signal?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  recommendation?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type AdvisorySignalCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  profileId?: Prisma.SortOrder
  cycleRunId?: Prisma.SortOrder
  signal?: Prisma.SortOrder
  confidence?: Prisma.SortOrder
  recommendation?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type AdvisorySignalAvgOrderByAggregateInput = {
  confidence?: Prisma.SortOrder
}

export type AdvisorySignalMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  profileId?: Prisma.SortOrder
  cycleRunId?: Prisma.SortOrder
  signal?: Prisma.SortOrder
  confidence?: Prisma.SortOrder
  recommendation?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type AdvisorySignalMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  profileId?: Prisma.SortOrder
  cycleRunId?: Prisma.SortOrder
  signal?: Prisma.SortOrder
  confidence?: Prisma.SortOrder
  recommendation?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type AdvisorySignalSumOrderByAggregateInput = {
  confidence?: Prisma.SortOrder
}



export type AdvisorySignalSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  profileId?: boolean
  cycleRunId?: boolean
  signal?: boolean
  confidence?: boolean
  recommendation?: boolean
  createdAt?: boolean
}, ExtArgs["result"]["advisorySignal"]>

export type AdvisorySignalSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  profileId?: boolean
  cycleRunId?: boolean
  signal?: boolean
  confidence?: boolean
  recommendation?: boolean
  createdAt?: boolean
}, ExtArgs["result"]["advisorySignal"]>

export type AdvisorySignalSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  profileId?: boolean
  cycleRunId?: boolean
  signal?: boolean
  confidence?: boolean
  recommendation?: boolean
  createdAt?: boolean
}, ExtArgs["result"]["advisorySignal"]>

export type AdvisorySignalSelectScalar = {
  id?: boolean
  profileId?: boolean
  cycleRunId?: boolean
  signal?: boolean
  confidence?: boolean
  recommendation?: boolean
  createdAt?: boolean
}

export type AdvisorySignalOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "profileId" | "cycleRunId" | "signal" | "confidence" | "recommendation" | "createdAt", ExtArgs["result"]["advisorySignal"]>

export type $AdvisorySignalPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "AdvisorySignal"
  objects: {}
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    profileId: string
    cycleRunId: string | null
    signal: string
    confidence: number
    recommendation: string
    createdAt: Date
  }, ExtArgs["result"]["advisorySignal"]>
  composites: {}
}

export type AdvisorySignalGetPayload<S extends boolean | null | undefined | AdvisorySignalDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$AdvisorySignalPayload, S>

export type AdvisorySignalCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<AdvisorySignalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AdvisorySignalCountAggregateInputType | true
  }

export interface AdvisorySignalDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdvisorySignal'], meta: { name: 'AdvisorySignal' } }
  /**
   * Find zero or one AdvisorySignal that matches the filter.
   * @param {AdvisorySignalFindUniqueArgs} args - Arguments to find a AdvisorySignal
   * @example
   * // Get one AdvisorySignal
   * const advisorySignal = await prisma.advisorySignal.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends AdvisorySignalFindUniqueArgs>(args: Prisma.SelectSubset<T, AdvisorySignalFindUniqueArgs<ExtArgs>>): Prisma.Prisma__AdvisorySignalClient<runtime.Types.Result.GetResult<Prisma.$AdvisorySignalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one AdvisorySignal that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {AdvisorySignalFindUniqueOrThrowArgs} args - Arguments to find a AdvisorySignal
   * @example
   * // Get one AdvisorySignal
   * const advisorySignal = await prisma.advisorySignal.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends AdvisorySignalFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, AdvisorySignalFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__AdvisorySignalClient<runtime.Types.Result.GetResult<Prisma.$AdvisorySignalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first AdvisorySignal that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AdvisorySignalFindFirstArgs} args - Arguments to find a AdvisorySignal
   * @example
   * // Get one AdvisorySignal
   * const advisorySignal = await prisma.advisorySignal.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends AdvisorySignalFindFirstArgs>(args?: Prisma.SelectSubset<T, AdvisorySignalFindFirstArgs<ExtArgs>>): Prisma.Prisma__AdvisorySignalClient<runtime.Types.Result.GetResult<Prisma.$AdvisorySignalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first AdvisorySignal that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AdvisorySignalFindFirstOrThrowArgs} args - Arguments to find a AdvisorySignal
   * @example
   * // Get one AdvisorySignal
   * const advisorySignal = await prisma.advisorySignal.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends AdvisorySignalFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, AdvisorySignalFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__AdvisorySignalClient<runtime.Types.Result.GetResult<Prisma.$AdvisorySignalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more AdvisorySignals that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AdvisorySignalFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all AdvisorySignals
   * const advisorySignals = await prisma.advisorySignal.findMany()
   * 
   * // Get first 10 AdvisorySignals
   * const advisorySignals = await prisma.advisorySignal.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const advisorySignalWithIdOnly = await prisma.advisorySignal.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends AdvisorySignalFindManyArgs>(args?: Prisma.SelectSubset<T, AdvisorySignalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$AdvisorySignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a AdvisorySignal.
   * @param {AdvisorySignalCreateArgs} args - Arguments to create a AdvisorySignal.
   * @example
   * // Create one AdvisorySignal
   * const AdvisorySignal = await prisma.advisorySignal.create({
   *   data: {
   *     // ... data to create a AdvisorySignal
   *   }
   * })
   * 
   */
  create<T extends AdvisorySignalCreateArgs>(args: Prisma.SelectSubset<T, AdvisorySignalCreateArgs<ExtArgs>>): Prisma.Prisma__AdvisorySignalClient<runtime.Types.Result.GetResult<Prisma.$AdvisorySignalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many AdvisorySignals.
   * @param {AdvisorySignalCreateManyArgs} args - Arguments to create many AdvisorySignals.
   * @example
   * // Create many AdvisorySignals
   * const advisorySignal = await prisma.advisorySignal.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends AdvisorySignalCreateManyArgs>(args?: Prisma.SelectSubset<T, AdvisorySignalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many AdvisorySignals and returns the data saved in the database.
   * @param {AdvisorySignalCreateManyAndReturnArgs} args - Arguments to create many AdvisorySignals.
   * @example
   * // Create many AdvisorySignals
   * const advisorySignal = await prisma.advisorySignal.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many AdvisorySignals and only return the `id`
   * const advisorySignalWithIdOnly = await prisma.advisorySignal.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends AdvisorySignalCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, AdvisorySignalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$AdvisorySignalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a AdvisorySignal.
   * @param {AdvisorySignalDeleteArgs} args - Arguments to delete one AdvisorySignal.
   * @example
   * // Delete one AdvisorySignal
   * const AdvisorySignal = await prisma.advisorySignal.delete({
   *   where: {
   *     // ... filter to delete one AdvisorySignal
   *   }
   * })
   * 
   */
  delete<T extends AdvisorySignalDeleteArgs>(args: Prisma.SelectSubset<T, AdvisorySignalDeleteArgs<ExtArgs>>): Prisma.Prisma__AdvisorySignalClient<runtime.Types.Result.GetResult<Prisma.$AdvisorySignalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one AdvisorySignal.
   * @param {AdvisorySignalUpdateArgs} args - Arguments to update one AdvisorySignal.
   * @example
   * // Update one AdvisorySignal
   * const advisorySignal = await prisma.advisorySignal.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends AdvisorySignalUpdateArgs>(args: Prisma.SelectSubset<T, AdvisorySignalUpdateArgs<ExtArgs>>): Prisma.Prisma__AdvisorySignalClient<runtime.Types.Result.GetResult<Prisma.$AdvisorySignalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more AdvisorySignals.
   * @param {AdvisorySignalDeleteManyArgs} args - Arguments to filter AdvisorySignals to delete.
   * @example
   * // Delete a few AdvisorySignals
   * const { count } = await prisma.advisorySignal.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends AdvisorySignalDeleteManyArgs>(args?: Prisma.SelectSubset<T, AdvisorySignalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more AdvisorySignals.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AdvisorySignalUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many AdvisorySignals
   * const advisorySignal = await prisma.advisorySignal.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends AdvisorySignalUpdateManyArgs>(args: Prisma.SelectSubset<T, AdvisorySignalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more AdvisorySignals and returns the data updated in the database.
   * @param {AdvisorySignalUpdateManyAndReturnArgs} args - Arguments to update many AdvisorySignals.
   * @example
   * // Update many AdvisorySignals
   * const advisorySignal = await prisma.advisorySignal.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more AdvisorySignals and only return the `id`
   * const advisorySignalWithIdOnly = await prisma.advisorySignal.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends AdvisorySignalUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, AdvisorySignalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$AdvisorySignalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one AdvisorySignal.
   * @param {AdvisorySignalUpsertArgs} args - Arguments to update or create a AdvisorySignal.
   * @example
   * // Update or create a AdvisorySignal
   * const advisorySignal = await prisma.advisorySignal.upsert({
   *   create: {
   *     // ... data to create a AdvisorySignal
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the AdvisorySignal we want to update
   *   }
   * })
   */
  upsert<T extends AdvisorySignalUpsertArgs>(args: Prisma.SelectSubset<T, AdvisorySignalUpsertArgs<ExtArgs>>): Prisma.Prisma__AdvisorySignalClient<runtime.Types.Result.GetResult<Prisma.$AdvisorySignalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of AdvisorySignals.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AdvisorySignalCountArgs} args - Arguments to filter AdvisorySignals to count.
   * @example
   * // Count the number of AdvisorySignals
   * const count = await prisma.advisorySignal.count({
   *   where: {
   *     // ... the filter for the AdvisorySignals we want to count
   *   }
   * })
  **/
  count<T extends AdvisorySignalCountArgs>(
    args?: Prisma.Subset<T, AdvisorySignalCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], AdvisorySignalCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a AdvisorySignal.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AdvisorySignalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends AdvisorySignalAggregateArgs>(args: Prisma.Subset<T, AdvisorySignalAggregateArgs>): Prisma.PrismaPromise<GetAdvisorySignalAggregateType<T>>

  /**
   * Group by AdvisorySignal.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AdvisorySignalGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends AdvisorySignalGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: AdvisorySignalGroupByArgs['orderBy'] }
      : { orderBy?: AdvisorySignalGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, AdvisorySignalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvisorySignalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the AdvisorySignal model
 */
readonly fields: AdvisorySignalFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for AdvisorySignal.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__AdvisorySignalClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the AdvisorySignal model
 */
export interface AdvisorySignalFieldRefs {
  readonly id: Prisma.FieldRef<"AdvisorySignal", 'String'>
  readonly profileId: Prisma.FieldRef<"AdvisorySignal", 'String'>
  readonly cycleRunId: Prisma.FieldRef<"AdvisorySignal", 'String'>
  readonly signal: Prisma.FieldRef<"AdvisorySignal", 'String'>
  readonly confidence: Prisma.FieldRef<"AdvisorySignal", 'Float'>
  readonly recommendation: Prisma.FieldRef<"AdvisorySignal", 'String'>
  readonly createdAt: Prisma.FieldRef<"AdvisorySignal", 'DateTime'>
}
    

// Custom InputTypes
/**
 * AdvisorySignal findUnique
 */
export type AdvisorySignalFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AdvisorySignal
   */
  select?: Prisma.AdvisorySignalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AdvisorySignal
   */
  omit?: Prisma.AdvisorySignalOmit<ExtArgs> | null
  /**
   * Filter, which AdvisorySignal to fetch.
   */
  where: Prisma.AdvisorySignalWhereUniqueInput
}

/**
 * AdvisorySignal findUniqueOrThrow
 */
export type AdvisorySignalFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AdvisorySignal
   */
  select?: Prisma.AdvisorySignalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AdvisorySignal
   */
  omit?: Prisma.AdvisorySignalOmit<ExtArgs> | null
  /**
   * Filter, which AdvisorySignal to fetch.
   */
  where: Prisma.AdvisorySignalWhereUniqueInput
}

/**
 * AdvisorySignal findFirst
 */
export type AdvisorySignalFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AdvisorySignal
   */
  select?: Prisma.AdvisorySignalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AdvisorySignal
   */
  omit?: Prisma.AdvisorySignalOmit<ExtArgs> | null
  /**
   * Filter, which AdvisorySignal to fetch.
   */
  where?: Prisma.AdvisorySignalWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of AdvisorySignals to fetch.
   */
  orderBy?: Prisma.AdvisorySignalOrderByWithRelationInput | Prisma.AdvisorySignalOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for AdvisorySignals.
   */
  cursor?: Prisma.AdvisorySignalWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` AdvisorySignals from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` AdvisorySignals.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of AdvisorySignals.
   */
  distinct?: Prisma.AdvisorySignalScalarFieldEnum | Prisma.AdvisorySignalScalarFieldEnum[]
}

/**
 * AdvisorySignal findFirstOrThrow
 */
export type AdvisorySignalFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AdvisorySignal
   */
  select?: Prisma.AdvisorySignalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AdvisorySignal
   */
  omit?: Prisma.AdvisorySignalOmit<ExtArgs> | null
  /**
   * Filter, which AdvisorySignal to fetch.
   */
  where?: Prisma.AdvisorySignalWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of AdvisorySignals to fetch.
   */
  orderBy?: Prisma.AdvisorySignalOrderByWithRelationInput | Prisma.AdvisorySignalOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for AdvisorySignals.
   */
  cursor?: Prisma.AdvisorySignalWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` AdvisorySignals from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` AdvisorySignals.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of AdvisorySignals.
   */
  distinct?: Prisma.AdvisorySignalScalarFieldEnum | Prisma.AdvisorySignalScalarFieldEnum[]
}

/**
 * AdvisorySignal findMany
 */
export type AdvisorySignalFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AdvisorySignal
   */
  select?: Prisma.AdvisorySignalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AdvisorySignal
   */
  omit?: Prisma.AdvisorySignalOmit<ExtArgs> | null
  /**
   * Filter, which AdvisorySignals to fetch.
   */
  where?: Prisma.AdvisorySignalWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of AdvisorySignals to fetch.
   */
  orderBy?: Prisma.AdvisorySignalOrderByWithRelationInput | Prisma.AdvisorySignalOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing AdvisorySignals.
   */
  cursor?: Prisma.AdvisorySignalWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` AdvisorySignals from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` AdvisorySignals.
   */
  skip?: number
  distinct?: Prisma.AdvisorySignalScalarFieldEnum | Prisma.AdvisorySignalScalarFieldEnum[]
}

/**
 * AdvisorySignal create
 */
export type AdvisorySignalCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AdvisorySignal
   */
  select?: Prisma.AdvisorySignalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AdvisorySignal
   */
  omit?: Prisma.AdvisorySignalOmit<ExtArgs> | null
  /**
   * The data needed to create a AdvisorySignal.
   */
  data: Prisma.XOR<Prisma.AdvisorySignalCreateInput, Prisma.AdvisorySignalUncheckedCreateInput>
}

/**
 * AdvisorySignal createMany
 */
export type AdvisorySignalCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many AdvisorySignals.
   */
  data: Prisma.AdvisorySignalCreateManyInput | Prisma.AdvisorySignalCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * AdvisorySignal createManyAndReturn
 */
export type AdvisorySignalCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AdvisorySignal
   */
  select?: Prisma.AdvisorySignalSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the AdvisorySignal
   */
  omit?: Prisma.AdvisorySignalOmit<ExtArgs> | null
  /**
   * The data used to create many AdvisorySignals.
   */
  data: Prisma.AdvisorySignalCreateManyInput | Prisma.AdvisorySignalCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * AdvisorySignal update
 */
export type AdvisorySignalUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AdvisorySignal
   */
  select?: Prisma.AdvisorySignalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AdvisorySignal
   */
  omit?: Prisma.AdvisorySignalOmit<ExtArgs> | null
  /**
   * The data needed to update a AdvisorySignal.
   */
  data: Prisma.XOR<Prisma.AdvisorySignalUpdateInput, Prisma.AdvisorySignalUncheckedUpdateInput>
  /**
   * Choose, which AdvisorySignal to update.
   */
  where: Prisma.AdvisorySignalWhereUniqueInput
}

/**
 * AdvisorySignal updateMany
 */
export type AdvisorySignalUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update AdvisorySignals.
   */
  data: Prisma.XOR<Prisma.AdvisorySignalUpdateManyMutationInput, Prisma.AdvisorySignalUncheckedUpdateManyInput>
  /**
   * Filter which AdvisorySignals to update
   */
  where?: Prisma.AdvisorySignalWhereInput
  /**
   * Limit how many AdvisorySignals to update.
   */
  limit?: number
}

/**
 * AdvisorySignal updateManyAndReturn
 */
export type AdvisorySignalUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AdvisorySignal
   */
  select?: Prisma.AdvisorySignalSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the AdvisorySignal
   */
  omit?: Prisma.AdvisorySignalOmit<ExtArgs> | null
  /**
   * The data used to update AdvisorySignals.
   */
  data: Prisma.XOR<Prisma.AdvisorySignalUpdateManyMutationInput, Prisma.AdvisorySignalUncheckedUpdateManyInput>
  /**
   * Filter which AdvisorySignals to update
   */
  where?: Prisma.AdvisorySignalWhereInput
  /**
   * Limit how many AdvisorySignals to update.
   */
  limit?: number
}

/**
 * AdvisorySignal upsert
 */
export type AdvisorySignalUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AdvisorySignal
   */
  select?: Prisma.AdvisorySignalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AdvisorySignal
   */
  omit?: Prisma.AdvisorySignalOmit<ExtArgs> | null
  /**
   * The filter to search for the AdvisorySignal to update in case it exists.
   */
  where: Prisma.AdvisorySignalWhereUniqueInput
  /**
   * In case the AdvisorySignal found by the `where` argument doesn't exist, create a new AdvisorySignal with this data.
   */
  create: Prisma.XOR<Prisma.AdvisorySignalCreateInput, Prisma.AdvisorySignalUncheckedCreateInput>
  /**
   * In case the AdvisorySignal was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.AdvisorySignalUpdateInput, Prisma.AdvisorySignalUncheckedUpdateInput>
}

/**
 * AdvisorySignal delete
 */
export type AdvisorySignalDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AdvisorySignal
   */
  select?: Prisma.AdvisorySignalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AdvisorySignal
   */
  omit?: Prisma.AdvisorySignalOmit<ExtArgs> | null
  /**
   * Filter which AdvisorySignal to delete.
   */
  where: Prisma.AdvisorySignalWhereUniqueInput
}

/**
 * AdvisorySignal deleteMany
 */
export type AdvisorySignalDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which AdvisorySignals to delete
   */
  where?: Prisma.AdvisorySignalWhereInput
  /**
   * Limit how many AdvisorySignals to delete.
   */
  limit?: number
}

/**
 * AdvisorySignal without action
 */
export type AdvisorySignalDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the AdvisorySignal
   */
  select?: Prisma.AdvisorySignalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the AdvisorySignal
   */
  omit?: Prisma.AdvisorySignalOmit<ExtArgs> | null
}

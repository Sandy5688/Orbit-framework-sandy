# ðŸ›°ï¸ Project: **ORBIT FRAMEWORK**
> Build a **modular, phased orchestration framework** for unattended execution, transformation, normalization, and dispatch of opaque payloads.
> All inputs, outputs, and behaviors are treated as **opaque abstractions**.
> All meaning is injected externally via configuration or interfaces.

###1. TECH CONSTRAINTS
* **Runtime:** Node.js (preferred) or Python
* **Scheduler:** cron / node-cron (or equivalent)
* **Storage:** PostgreSQL or SQLite
* **Processing:** External processor (e.g., FFmpeg)
* **Transport:** REST with token-based authentication
* **Configuration:** JSON / YAML
* **Secrets:** `.env` only
* **Deployment:** Docker-ready, VPS-compatible

###2. PHASED ARCHITECTURE OVERVIEW
| Phase   | Purpose                                        
| Phase-1 | Core unattended execution infrastructure       
| Phase-2 | Configurable abstraction & value attribution   
| Phase-3 | Telemetry, correlation, and advisory signals   
| Phase-4 | Controlled autonomy (implemented but disabled) 

###3.  PHASE-1: CORE EXECUTION INFRASTRUCTURE

### A. Cycle Orchestrator
* Triggers scheduled execution (default: twice daily)
* Global pause via environment flag
* Partial failures must not halt execution

### B. Initiation Selector
Generates one unique initiation object per cycle.
```json
{
  "id": "uuid",
  "label": "string",
  "weight": number,
  "metadata": {}
}
**Requirements**
* Hash-based deduplication
* History tracking
* Stateless generation

### C. Tiered Transformation Interfaces
Implement three transformation tiers:
| Tier   | Responsibility                               
| Tier-1 | Accepts initiation object, returns opaque payload           
| Tier-2 | Accepts Tier-1 output, returns binary payload               
| Tier-3 | Accepts Tier-2 output + reference, returns formatted binary 
**Rules**
* All payloads are opaque
* Async support required
* Retry: max 3 attempts with exponential backoff
* Validation without interpretation

### D. Normalization Engine
* Applies standardized transformations via external processor
* Supports batch handling

### E. Dispatch Queue
* Queue-based delivery to configurable endpoints
* No hard-coded logic
* Delivery receipts captured

### F. Recorder
* Logs execution outcomes
* Tracks partial success and failure
* Append-only records


###4. PHASE-2: CONFIGURABLE ABSTRACTION LAYER

### A. Profile Engine
Profiles define execution identity and behavior.

```json
{
  "profile_id": "uuid",
  "label": "string",
  "style_vector": {},
  "asset_bindings": {},
  "execution_rules": {},
  "distribution_map": [],
  "value_tags": [],
  "state": "enabled | paused | archived"
}
```**Requirements**
* Fully config-driven
* Unlimited profiles
* Hot enable/disable
* Clonable via config duplication

### B. Instruction Synthesis
Produces stateless directives.
```json
{
  "instruction_id": "uuid",
  "context_blob": "...",
  "constraints": {},
  "priority": 0.0
}
``

### C. Run Profile Orchestration
Supports parallel execution surfaces.

```json
{
  "run_profile_id": "uuid",
  "execution_policy": {},
  "asset_bundle": {},
  "distribution_targets": [],
  "value_tags": []
}
`` Independently schedulable
* Toggleable and clonable
* Behavior modified via config only


### D. Bridge Interface
* Sends structured execution requests to Phase-1
* Ingests artifacts and receipts
* Persists metadata and references


### E. Value Tagging & Metering
* Attaches usage markers and weights
* Immutable, append-only ledger
* No billing, pricing, or enforcement logic

### F. Signal Tracker
* Tracks execution frequency
* Tracks delivery outcomes
* Flags anomalies via rules
* No adaptive behavior

###5. PHASE-3: OBSERVABILITY & ADVISORY LAYER

### A. Event Telemetry Bus

Emits normalized, replayable events:
* execution_started
* artifact_emitted
* delivery_confirmed
* anomaly_detected

Each event includes:
* profile_id
* run_id
* timestamp
* opaque metadata

### B. Performance Correlation Engine
* Aggregates telemetry
* Computes ratios, latency bands, volatility
* Outputs **read-only advisory signals**

```json
{
  "profile_id": "...",
  "signal": "elevated_performance",
  "confidence": 0.82,
  "recommendation": "adjust_weight"
}
```
### C. Strategy Suggestion Layer
* Generates logged proposals
* Requires human approval
* Must never auto-apply changes

### D. Isolation Framework
* Namespace separation
* Hard isolation of profiles, ledgers, telemetry
* No cross-namespace writes

### E. Governance & Safety
* Execution caps
* Anomaly thresholds
* Emergency halt (global & per-namespace)
* Immutable audit trail
* Hot-reload with versioned config snapshots

### F. Micro-Enhancements
* Advisory similarity gating
* Shadow simulation overlays
* Signal confidence decay

###6. PHASE-4: CONTROLLED AUTONOMY (DISABLED)

Implemented behind **hard feature flags** (OFF by default):
* Autonomous profile mutation
* Persistent artifact identity
* Dynamic value modeling
* Cross-namespace anonymized insights
* Intentional non-determinism
**Constraint:**
Phase-4 capabilities must never self-activate and must require explicit operator authorization.

###7. DELIVERY REQUIREMENTS

The developer must deliver:

* Functional private repository
* `.env.example`
* Sample configuration files
* Schema definitions (DB or file-based)
* REST contract documentation
* Dockerfile & setup guide
* README including:
  * System topology
  * Profile & run lifecycle
  * Event and ledger flow
  * Safety guarantees

###8. ACCEPTANCE CRITERIA
* One full end-to-end execution cycle
* Fault isolation verified
* Config-only behavior changes
* No embedded semantics
* No hard-coded strategy
generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model CycleRun {
  id          String   @id @default(cuid())
  startedAt   DateTime @default(now())
  finishedAt  DateTime?
  status      String   // running | success | partial_success | failed
  contextJson Json?

  initiations Initiation[]
  records     ExecutionRecord[]
  checkpoints CycleCheckpoint[]
}

model Initiation {
  id          String   @id @default(cuid())
  label       String
  weight      Float
  metadata    Json
  /// Deterministic hash for idempotent execution per run profile / context.
  initiationHash String
  createdAt   DateTime @default(now())

  /// Run profile identifier from config that produced this initiation (if any).
  runProfileId String?

  cycleRunId  String?
  cycleRun    CycleRun? @relation(fields: [cycleRunId], references: [id])

  transformations Transformation[]

  @@index([initiationHash])
  /// Prevent duplicate initiations for the same logical execution and run profile.
  @@unique([initiationHash, runProfileId])
}

model Transformation {
  id             String   @id @default(cuid())
  tier           Int      // 1, 2, 3
  attempt        Int
  status         String   // pending | success | failed
  errorMessage   String?
  createdAt      DateTime @default(now())

  initiationId   String?
  initiation     Initiation? @relation(fields: [initiationId], references: [id])

  normalizationItems NormalizationItem[]
}

model NormalizationBatch {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  status       String   // pending | processing | partial_failed | completed | failed
  processorRef String?

  items        NormalizationItem[]
}

model NormalizationItem {
  id                   String             @id @default(cuid())
  status               String             // pending | success | failed
  errorMessage         String?
  createdAt            DateTime           @default(now())

  batchId              String?
  batch                NormalizationBatch? @relation(fields: [batchId], references: [id])

  transformationId     String?
  transformation       Transformation?    @relation(fields: [transformationId], references: [id])

  dispatchJobs         DispatchJob[]
  deadLetterDispatches DeadLetterDispatch[]
}

model DispatchJob {
  id                 String   @id @default(cuid())
  endpointKey        String
  status             String   // pending | delivering | delivered | failed
  attempt            Int      @default(0)
  /// Snapshot of endpoint URL at enqueue time for rotation safety.
  endpointUrl        String?
  /// Snapshot of HTTP method at enqueue time for rotation safety.
  endpointMethod     String?
  /// Snapshot of auth token/secret at enqueue time for rotation safety.
  tokenSnapshot      String?
  lastError          String?
  receiptJson        Json?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  normalizationItemId String?
  normalizationItem   NormalizationItem? @relation(fields: [normalizationItemId], references: [id])
  deadLetterEntries   DeadLetterDispatch[]
}

model ExecutionRecord {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  scope      String   // cycle | initiation | transformation | normalization | dispatch | governance
  refId      String?
  level      String   // info | warning | error
  message    String
  details    Json?

  cycleRunId String?
  cycleRun   CycleRun? @relation(fields: [cycleRunId], references: [id])
}

model TelemetryEvent {
  id         String   @id @default(cuid())
  eventType  String   // execution_started | artifact_emitted | delivery_confirmed | anomaly_detected
  cycleRunId String?
  profileId  String?
  runId      String?
  namespace  String?
  timestamp  DateTime @default(now())
  metadata   Json

  @@index([eventType])
  @@index([profileId])
  @@index([runId])
}

/// Cold archive table for telemetry events that have been pruned from the hot
/// TelemetryEvent table.
model TelemetryArchive {
  id         String   @id @default(cuid())
  eventType  String
  cycleRunId String?
  profileId  String?
  runId      String?
  namespace  String?
  timestamp  DateTime
  metadata   Json
  archivedAt DateTime @default(now())
}

model AdvisorySignal {
  id            String   @id @default(cuid())
  profileId     String
  cycleRunId    String?
  signal        String
  confidence    Float
  recommendation String
  createdAt     DateTime @default(now())

  @@index([profileId])
}

model StrategyProposal {
  id             String   @id @default(cuid())
  profileId      String
  cycleRunId     String?
  signalId       String?
  description    String
  suggestedChange Json
  status         String   // pending | approved | rejected
  createdAt      DateTime @default(now())
}

model ValueLedgerEntry {
  id           String   @id @default(cuid())
  profileId    String
  /// cycle_run_id the value tags were associated with (typically CycleRun.id)
  cycleRunId   String?
  runId        String?
  valueTags    Json
  weight       Float
  metadata     Json?
  createdAt    DateTime @default(now())
}

model GovernanceSetting {
  id             String   @id @default(cuid())
  namespace      String
  key            String
  value          Json
  createdAt      DateTime @default(now())

  @@unique([namespace, key])
}

model AuditTrailEntry {
  id           String   @id @default(cuid())
  cycleRunId   String?
  namespace    String?
  actor        String?
  action       String
  details      Json?
  createdAt    DateTime @default(now())
}

/// Append-only cycle checkpoint log used for crash-resilient recovery.
model CycleCheckpoint {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  /// e.g. cycle_started | tier1_complete | tier2_complete | tier3_complete | dispatch_complete | cycle_finished
  stage      String
  details    Json?

  cycleRunId String
  cycleRun   CycleRun @relation(fields: [cycleRunId], references: [id])

  @@index([cycleRunId, createdAt])
}

/// Dead-letter queue entry for dispatch jobs that exceeded retry thresholds.
model DeadLetterDispatch {
  id                 String   @id @default(cuid())
  createdAt          DateTime @default(now())
  requeuedAt         DateTime?
  dispatchJobId      String
  normalizationItemId String?
  endpointKey        String
  lastStatus         Int?
  lastError          String?
  payloadMeta        Json?

  dispatchJob        DispatchJob @relation(fields: [dispatchJobId], references: [id])
  normalizationItem  NormalizationItem? @relation(fields: [normalizationItemId], references: [id])

  @@index([createdAt])
}


